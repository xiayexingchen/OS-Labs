进程调度模拟系统设计方案报告

一．系统概述
本系统是一个进程调度模拟系统，采用前后端分离架构，使用了策略模式、MVC架构模式、DTO数据传输模式、单例模式和工厂模式等多种设计模式进行框架搭建与代码规范。系统模拟4核CPU环境，支持多种经典调度算法，包括先来先服务（FCFS）、最短作业优先（SJF）、最高响应比优先（HRN）、轮转调度（RR）和静态优先级调度（Priority）。系统通过RESTful API与前端进行交互，接收进程列表和调度算法选择，模拟进程调度过程，并返回调度状态和性能统计信息。用户可通过友好的图形化界面查看所有调度信息，无需了解底层实现细节。

二．用户功能
用户可通过图形化界面执行以下操作：
1. 进程管理
   - 添加单个或批量添加进程，设置进程的到达时间、服务时间、工作大小和优先级
   - 删除进程
   - 修改现有进程的属性

2. 算法选择
   - 从下拉菜单中选择不同的调度算法
   - 对于轮转调度算法，可自定义设置时间片大小

3. 调度控制
   - 初始化调度器
   - 单步执行调度过程，观察每一时间片的状态变化
   - 一键运行到调度结束
   - 重置调度状态
   - 完全重置系统状态

4. 状态监控
   - 实时查看当前时间
   - 监控各CPU核心上运行的进程
   - 查看就绪队列中的进程
   - 查看已完成进程列表
   - 观察进程执行时间线

5. 性能分析
   - 查看平均等待时间、平均周转时间和平均带权周转时间
   - 查看各个进程的详细统计信息

三．系统架构
3.1 前后端分离
   - 后端：Java Spring Boot框架，提供RESTful API接口
   - 前端：Vue.js框架，结合Vue CLI构建用户界面
   - 通信：基于HTTP协议的AJAX请求

3.2 后端设计
后端架构采用经典的MVC模式，各模块职责明确，松耦合高内聚。系统支持5种调度算法，通过策略模式实现算法的可扩展性。

3.3 分层架构
   - Controller层：负责处理HTTP请求，接收前端数据，调用Service层方法，并返回响应结果
   - Service层：实现业务逻辑，如进程调度、状态更新和性能计算
   - Model层：定义系统中的数据模型，如进程控制块（PCB）、核心（Core）和调度结果（ScheduleResult）
   - Algorithm层：实现各种调度算法，提供统一的接口供Service层调用
   - DTO层：定义数据传输对象，用于前后端数据交换

3.4 模块划分
   - SchedulerController：处理所有与调度相关的HTTP请求
   - SchedulerService：负责调度系统的核心业务逻辑
   - ProcessControlBlock：表示进程的基本信息和状态
   - Core：表示CPU核心，记录当前运行的进程
   - ISchedulingAlgorithm：调度算法的接口，所有具体算法都实现该接口
   - FCFSAlgorithm、SJFAlgorithm、HRNAlgorithm、RoundRobinAlgorithm、PriorityAlgorithm：具体的调度算法实现
   - InitRequestDTO、SchedulerStatusDTO：用于前后端数据传输的对象

四．核心类设计
4.1 进程控制块（ProcessControlBlock）
   - 核心属性：
     - pid：进程唯一标识符
     - arrivalTime：进程到达时间
     - burstTime：进程所需的总服务时间
     - remainingTime：进程剩余的服务时间
     - jobSize：作业大小
     - priority：进程优先级
     - status：进程状态（READY、RUNNING、FINISHED）
     - startTime：进程实际开始运行时间
     - finishTime：进程完成时间
     - waitingTime：进程等待时间
     - turnaroundTime：进程周转时间
     - weightedTurnaroundTime：进程带权周转时间
   - 构造方法：接收pid、arrivalTime、burstTime、jobSize、priority参数，初始化进程状态为READY

4.2 CPU核心（Core）
   - 核心属性：
     - coreId：核心唯一标识符
     - runningProcess：当前运行的进程
   - 主要方法：
     - isIdle()：判断核心是否空闲
     - getRunningProcess()：获取当前运行的进程
     - setRunningProcess()：设置运行的进程

4.3 进程状态（ProcessStatus）
   - 枚举类型，定义进程的三种状态：
     - READY：进程已就绪，等待CPU分配
     - RUNNING：进程正在CPU上运行
     - FINISHED：进程已执行完成

4.4 调度算法接口（ISchedulingAlgorithm）
   - 核心方法：
     - selectProcesses(readyQueue, cores, currentTime)：根据算法规则从就绪队列中选择可运行的进程
     - getName()：返回算法名称

4.5 调度器服务（SchedulerService）
   - 核心属性：
     - processList：所有进程列表
     - readyQueue：就绪队列
     - finishedQueue：完成队列
     - cores：4核模拟列表
     - currentTime：当前系统时间
     - algorithm：当前使用的调度算法
   - 主要方法：
     - initProcesses(processes)：初始化进程列表
     - scheduleStep()：执行一步调度
     - isAllFinished()：判断是否所有进程都已完成
     - calculatePerformance()：计算性能指标
     - runToEnd()：一次性运行完所有调度
     - reset()：重置系统状态

4.6 调度控制器（SchedulerController）
   - 核心方法：
     - init(InitRequestDTO)：初始化进程列表和选择算法
     - step()：执行单步调度
     - runAll()：运行到结束
     - status()：获取当前状态
     - performance()：获取性能统计
     - reset()：重置系统

五．算法实现
5.1 先来先服务算法（FCFS）
   - 原理：按照进程到达时间的先后顺序进行调度
   - 实现：
     1. 将就绪队列中的进程按到达时间升序排序
     2. 最多选择4个进程分配给空闲核心

5.2 最短作业优先算法（SJF）
   - 原理：优先选择剩余服务时间最短的进程
   - 实现：
     1. 统计当前空闲核心数量
     2. 过滤出所有状态为READY的进程
     3. 按剩余运行时间升序排列
     4. 选择前freeCores个进程分配给空闲核心

5.3 优先级调度算法（Priority）
   - 原理：优先选择优先级高的进程
   - 实现：
     1. 统计当前空闲核心数量
     2. 过滤出所有状态为READY的进程
     3. 按优先级降序排列，优先级相同时按到达时间升序排列
     4. 选择前freeCores个进程分配给空闲核心

5.4 最高响应比优先算法（HRN）
   - 原理：优先选择响应比最高的进程，响应比 = (等待时间 + 服务时间) / 服务时间
   - 实现：
     1. 统计当前空闲核心数量
     2. 过滤出所有状态为READY的进程
     3. 按响应比降序排列
     4. 选择前freeCores个进程分配给空闲核心
   - 核心辅助方法：calcResponseRatio(pcb, currentTime) 计算进程的响应比

5.5 轮转调度算法（RR）
   - 原理：每个进程分配固定的时间片，时间片用完后如果进程未完成则回到就绪队列末尾
   - 实现：
     1. 维护一个专门的轮转队列rrQueue
     2. 将就绪队列中不在轮转队列的READY进程加入轮转队列
     3. 移除轮转队列中已完成或不在就绪队列的进程
     4. 统计当前空闲核心数量
     5. 从轮转队列中顺序选择可分配的进程
     6. 每个进程执行一个时间片，若未完成则回到队列末尾

六．前端界面设计
6.1 整体布局
   - 顶部导航栏：显示系统名称和实验切换
   - 主要功能区：包含进程输入、算法选择、控制操作、状态显示和性能统计等模块

6.2 进程输入模块（ProcessInputTable.vue）
   - 功能描述：以表格形式展示进程信息，允许用户添加、删除和修改进程
   - 主要组件：
     - 添加进程按钮
     - 批量添加按钮和模态框
     - 进程表格显示
     - 编辑和删除功能
   - 数据交互：通过props接收进程列表，通过emit事件向父组件发送添加、删除和更新进程的请求

6.3 算法选择模块（AlgorithmSelector.vue）
   - 功能描述：提供下拉框供用户选择调度算法，对于RR算法可设置时间片大小
   - 主要组件：
     - 算法选择下拉菜单
     - 算法描述信息显示
     - 时间片设置滑块（仅RR算法显示）
     - 时间片推荐信息
   - 数据交互：通过props接收当前算法和时间片，通过emit事件向父组件发送更新请求

6.4 控制操作模块（SchedulerControl.vue）
   - 功能描述：提供初始化、单步执行、运行到底、重置和全部重置等控制按钮
   - 主要组件：
     - 初始化按钮
     - 单步执行按钮
     - 运行到底按钮
     - 重置按钮
     - 全部重置按钮
     - 状态提示信息
   - 数据交互：通过props接收初始化状态，通过emit事件向父组件发送控制请求

6.5 状态展示模块（SchedulerStatus.vue）
   - 功能描述：显示当前调度状态，包括时间、运行中进程、就绪队列、已完成队列和时间线
   - 主要组件：
     - 当前时间显示卡片
     - 运行中进程显示卡片
     - 就绪队列显示卡片
     - 已完成队列显示卡片
     - 执行时间线可视化
   - 数据交互：通过props接收当前状态信息

6.6 性能统计模块（PerformanceStats.vue）
   - 功能描述：显示性能统计信息，包括平均等待时间、平均周转时间和平均带权周转时间
   - 主要组件：
     - 统计卡片网格（等待时间、周转时间、带权周转时间）
     - 进度条可视化
     - 进程详细统计表格
   - 数据交互：通过props接收性能统计数据

七．运行流程
7.1 初始化阶段
   - 前端用户输入进程信息并选择调度算法
   - 点击"初始化"按钮，前端发送POST请求到/api/scheduler/init接口
   - 后端接收InitRequestDTO对象，初始化SchedulerService的进程列表和算法
   - 后端返回初始状态的SchedulerStatusDTO对象
   - 前端更新状态显示

7.2 运行阶段
   - 单步执行：点击"单步执行"按钮，前端发送POST请求到/api/scheduler/step接口
   - 运行到底：点击"运行到底"按钮，前端发送POST请求到/api/scheduler/run接口
   - 后端执行调度逻辑：
     1. 更新已到达的进程到就绪队列
     2. 回收已完成进程
     3. 调用当前算法的selectProcesses方法选择进程
     4. 分配进程到空闲核心
     5. 运行中的进程减少剩余时间
     6. 更新进程状态和统计信息
     7. 更新系统时间
   - 后端返回更新后的SchedulerStatusDTO对象
   - 前端实时更新状态显示

7.3 结果分析阶段
   - 调度完成后，前端显示最终状态和性能统计信息
   - 用户可以查看平均等待时间、平均周转时间和平均带权周转时间
   - 用户可以查看每个进程的详细统计信息

7.4 重置阶段
   - 点击"重置"按钮：重置调度状态，但保留进程列表和算法选择
   - 点击"全部重置"按钮：完全重置系统，清空进程列表和恢复默认设置

八．系统特点
8.1 模块化设计
   - 采用MVC架构，各模块职责明确，便于维护和扩展
   - 使用策略模式实现算法的可插拔性，易于添加新算法

8.2 多算法支持
   - 实现了五种经典调度算法：FCFS、SJF、Priority、HRN和RR
   - 算法实现遵循统一接口，便于比较不同算法的性能

8.3 多核模拟
   - 模拟4核CPU环境，支持多进程并行执行
   - 合理分配进程到空闲核心，充分利用CPU资源

8.4 友好的用户界面
   - 采用现代化的Vue.js前端框架
   - 提供直观的图形化界面，支持实时状态监控
   - 丰富的交互功能，如添加/删除进程、选择算法、控制调度流程

8.5 实时性能分析
   - 实时计算和显示各项性能指标
   - 提供进度条可视化和详细的进程统计表格

九．代码优化建议
9.1 性能优化
   - 使用线程池处理异步请求，提高系统并发能力
   - 优化调度算法中的排序和筛选操作，减少时间复杂度
   - 采用更高效的数据结构，如优先队列（PriorityQueue）用于SJF和Priority算法

9.2 功能扩展
   - 添加更高级的调度算法，如多级反馈队列调度（MLFQ）
   - 支持动态优先级调整
   - 增加进程间通信和资源竞争模拟
   - 添加可视化图表，如甘特图展示进程执行情况

9.3 代码质量提升
   - 增加单元测试和集成测试，提高代码健壮性
   - 完善异常处理机制，提高系统稳定性
   - 优化日志系统，便于问题排查
   - 改进代码结构，减少耦合度

9.4 用户体验优化
   - 添加进程模板和算法推荐功能
   - 优化响应速度，减少用户等待时间
   - 增加数据导出功能，支持将结果导出为Excel或CSV格式

十．总结
本进程调度模拟系统成功实现了五种经典调度算法，并通过友好的用户界面进行展示。系统采用前后端分离架构，具有良好的扩展性和可维护性。通过模拟4核CPU环境，系统能够真实地展示多进程并行调度的过程和结果。用户可以通过简单的操作添加进程、选择算法、控制调度流程，并实时查看调度状态和性能统计信息。

系统不仅是一个教学工具，帮助学生理解进程调度的基本原理和各种算法的特点，也是一个研究平台，可以用于比较不同调度算法的性能，探索更优的调度策略。通过进一步的功能扩展和性能优化，系统可以应用于更广泛的场景，如操作系统课程教学、调度算法研究和性能分析等领域。